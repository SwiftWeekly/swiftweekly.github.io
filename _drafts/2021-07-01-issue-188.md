---
layout: post
title: ! 'Issue #188'
author: fassko
sponsor:
    link: TODO
    heading: TODO
    body: TODO
    displaylink: TODO
---

* silent after WWDC
* Swift Unwrapped podcast ended

<!--excerpt-->

{% include sponsor.html %}

### Starter tasks

* [SR-14824](https://bugs.swift.org/browse/SR-14824) [Compiler] Improve diagnostic for multi-statement closures instead of saying "too complex closure return type"

### Podcasts

After 4.5 years, 92 episodes, and 830k downloads, Swift Unwrapped is wrapping up. In the last episode [92: Deinit](https://swiftunwrapped.github.io/episodes/xyd_XEwO/) [Jesse Squires](https://twitter.com/jesse_squires) and [JP Simard](https://twitter.com/simjp) talks about the history of the show and more.

### News and community

[Tibor Bödecs](https://twitter.com/tiborbodecs) wrote [a great tutorial](https://theswiftdev.com/swift-actors-tutorial-a-beginners-guide-to-thread-safe-concurrency/) about Swift actors.

### Commits and pull requests

> TODO

### Accepted proposals

> TODO

### Returned proposals

> TODO

### Rejected proposals

> TODO

### Proposals in review

[SE-0296](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md): *Allow overloads that differ only in async* [amendment](https://github.com/apple/swift-evolution/pull/1392) is [under review](https://forums.swift.org/t/amendment-se-0296-allow-overloads-that-differ-only-in-async/49808).

> Based on the [discussion of the first pitch](https://forums.swift.org/t/concurrency-asynchronous-functions/41619), this ability was [removed from the proposal](https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md#revision-history). However, experience [augmenting existing Swift libraries with async/await functionality](https://forums.swift.org/t/async-feedback-overloads-that-differ-only-in-async/49573) has demonstrated that this overloading might be useful, so we would like to reconsider the limitation.

[SE-0315](https://github.com/apple/swift-evolution/blob/main/proposals/0315-placeholder-types.md): *Placeholder types* is [under review](https://forums.swift.org/t/se-0315-placeholder-types/49801).

> Swift's type inference system is quite powerful, but there are many situations where it is impossible (or simply infeasible) for the compiler to work out the type of an expression, or where the user needs to override the default types worked out by the compiler. Directly referencing the heavily-overloaded `Double.init` initializer, as seen above, is one such situation where the compiler does not have the necessary context to determine the type of the expression without additional context.

[SE-0316](https://github.com/apple/swift-evolution/blob/main/proposals/0316-global-actors.md): *Placeholder types* is [under the second review](https://forums.swift.org/t/se-0316-second-review-global-actors/49804).

> The [previous review](https://forums.swift.org/t/se-0316-global-actors/48905) ended on June 7th. Relative to the previous review, the following changes have been made:
> 
> * Added the `GlobalActor` protocol, to which all global actors implictly conform.
> * Remove the requirement that all global and static variables be annotated with a global actor.
> * Added a grammar for closure attributes.
> * Clarified the interaction between the main actor and the main thread. Make the main actor a little less "special" in the initial presentation.

[SE-0314](https://github.com/apple/swift-evolution/blob/main/proposals/0314-async-stream.md): *AsyncStream and AsyncThrowingStream* is [under the second review](https://forums.swift.org/t/se-0314-second-review-asyncstream-and-asyncthrowingstream/49803).

> The [first review 7](https://forums.swift.org/t/se-0314-asyncstream-and-asyncthrowingstream/48198/33) received a lot of very useful feedback. In response, the authors have made several changes to the proposal for the second review, summarized here:
> 
> * added `YieldResult` to express the action of yielding’s impact, either something is enqueued, dropped or the continuation is already terminated
> * added `init(unfolding: @escaping () async -> Element?)` to offer an initializer for unfolding to handle back-pressure based APIs.
> * made `AsyncThrowingStream` generic on Failure but the initializers only afford for creation `where Failure == Error`
> * removed the example of `DispatchSource` signals since the other `DispatchSource` types might be actively harmful to use in _any_ async context
> * initialization now takes a buffering policy to both restrict the buffer size as well as configure how elements are dropped

### Swift Forums

[Ole Begemann](https://twitter.com/olebegemann) started [a discussion](https://forums.swift.org/t/running-an-async-task-with-a-timeout/49733) about running an async task with a timeout.

> I wrote a function `async(timeoutAfter:work:)`. Its goal is to run an async task with a timeout. If the timeout expires and the work hasn't completed, it should cancel the task and throw a `TimedOutError`.

[Isabel Lima](https://forums.swift.org/u/iillx) pitched [a proposal](https://forums.swift.org/t/add-shared-storage-to-property-wrappers/49898) that would add a shared storage to property wrappers.

> Property Wrappers are responsible for wrapping common getting and setting boilerplate and also for storing any auxiliary helper properties. Often, these helpers are constant across different instances of the wrapper, not changing after initialization. Thus, having to store these properties in each individual wrapper instance should be avoided. In the following `Clamped` example, every wrapped instance will store its own `range` — even though there isn't a way for this range to change across different `Hud` initializations.

[Tim Condon](https://twitter.com/0xTim) briefed about Swift on the Server Workgroup [May 26th 2021 meeting](https://forums.swift.org/t/may-26th-2021/49863).

[Doug Gregor](https://twitter.com/dgregor79) informed us about the [amendment](https://github.com/apple/swift-evolution/pull/1397) to [SE-0313](https://github.com/apple/swift-evolution/blob/main/proposals/0313-actor-isolation-control.md).

> .. requires any `nonisolated` declaration to only involve `Sendable` types. This eliminates the potential for data races due to non-`Sendable` values being accessible from any actor.

[Becca Royal-Gordon](https://twitter.com/beccadax) pitched [an idea](https://forums.swift.org/t/pre-pitch-import-access-control-a-modest-proposal/50087) to improve the import access control.

> Over the last few years, the `import` statement has been collecting unofficial, unsupported features to help manage the dependencies between libraries. We ([@xymus](https://forums.swift.org/u/xymus) and [@beccadax](https://forums.swift.org/u/beccadax)) are thinking about how to stabilize some of these into officially-supported language features.
> 
> Chief among them is the `@_implementationOnly` attribute. An `@_implementationOnly import` is completely hidden from clients who import your module. This allows clients to import your module even if they do not have access to that module, so it's great for hiding libraries that you use only as an implementation detail. To make this work, though, the compiler stops you from using a declaration imported via an `@_implementationOnly import` in a `public`, `open`, or `@usableFromInline` declaration (including the function body if it's `@inlinable`) if that use would be visible to your clients.

### Finally

* [When it hits you that async/await requires iOS 15](https://twitter.com/harshil/status/1405376218665406466).
* [[Pitch] Allow async functions to specify hold music while being awaited](https://twitter.com/jckarter/status/1405988641726365697)
* [Dracula](https://twitter.com/jckarter/status/1407095099046039554)