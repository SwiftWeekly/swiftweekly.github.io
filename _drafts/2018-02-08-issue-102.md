---
layout: post
title: ! 'Issue #102'
author: tapthaker
---

> TODO: intro comments

<!--excerpt-->

### Starter tasks

- [SR-6852](https://bugs.swift.org/browse/SR-6852) Support `#if swift(<4.1)` *#compiler*
- [SR-6808](https://bugs.swift.org/browse/SR-6808) Visualizing Build Graph is not exposed from llbuild Build System *#llbuild*
- [SR-6787](https://bugs.swift.org/browse/SR-6787) Unexpected result when getting a String describing a type created inside a function *#bug* *#standard-library*

{% include task_remind.html %}

### Swift Unwrapped

[Swift Bi-Weekly Brief](https://spec.fm/podcasts/swift-unwrapped/108765)

### News and community

[Greg Heo](https://twitter.com/gregheo) wrote an amazing post about [Conditional conformance](https://swiftunboxed.com/lang/conditional-conformance/). In it, he thinks through conditional conformance in Swift, and works through the basics of its implementation.

[Xi Ge](https://github.com/nkcsgexi)'s talk about [Creating Refactoring Transformations for Swift](https://www.skilled.io/u/swiftsummit/creating-refactoring-transformations-for-swift) from the [Swift Summit 2017](https://www.swiftsummit.com/) is posted. He also talks about future of refactoring engine with [libSyntax](https://github.com/apple/swift/blob/master/lib/Syntax/README.md).

[Brandon Williams](http://www.fewbutripe.com/about/) and [Stephen Celis](http://www.stephencelis.com/) launched a new Swift video series called [Point-Free](https://www.pointfree.co/). Checkout their first episode, [Functions](https://www.pointfree.co/episodes/ep1-functions).
>Point-Free is a video series about functional programming and the Swift programming language. Each episode covers a topic that may seem complex and academic at first, but turns out to be quite simple. At the end of each episode we’ll ask “what’s the point?!”, so that we can bring the concepts back down to earth and show how these ideas can improve the quality of your code today.

Brandon's talk [Server-Side Swift from Scratch](https://www.skilled.io/u/swiftsummit/server-side-swift-from-scratch) also discusses some of the functional programming work they have done with Point-Free

[Peter Steinberger](https://twitter.com/steipete) wrote about [Binary Frameworks in Swift](https://pspdfkit.com/blog/2018/binary-frameworks-swift/)
> This article explores what ABI means and how it can be important for third-party frameworks.
>
> TL;WR: ABI stability won’t change much for you, and it’s not enough to ship binary Swift frameworks.

### Commits and pull requests

[Doug Gregor](https://github.com/DougGregor) has merged several pull requests:

- [merged](https://github.com/apple/swift/pull/14296) a pull request that mangles retroactive conformances as part of bound generic types.<br/>
>A "retroactive" protocol conformance is a conformance that is provided
by a module that is neither the module that defines the protocol nor
the module that defines the conforming type. It is possible for such
conformances to conflict at runtime, if defined in different modules
that were not both visible to the compiler at the same time.
<br/>When mangling a bound generic type, also mangle retroactive protocol
conformances that were needed to satisfy the generic requirements of
the generic type. This prevents name collisions between (e.g.) types
formed using retroactive conformances from different modules. The
impact on the size of the mangling is expected to be relatively small,
because most conformances are not retroactive.

- [merged]((https://github.com/apple/swift/pull/14327)) a pull request that dynamically checks generic constraints when forming type info (e.g., Any.Type) from a mangled name.<br/>
>Extend support for mapping a mangled name -> type metadata to include
support for checking protocol conformance requirements, using the
encoding of generic requirements that is now available within context
descriptors. For example, this allows
`_typeByMangledName(mangled-name-of-Set<Int>)` to construct proper type
metadata, filling in the Int: Hashable requirement as appropriate.

- [merged](https://github.com/apple/swift/pull/14368) a pull request that will allow querying of conditional conformances at runtime. This was the last major part of implementing [SE-0143](https://github.com/apple/swift-evolution/blob/master/proposals/0143-conditional-conformances.md) *Conditional conformances* which is now complete 🎉.
>Runtime query of conditional conformances is now implemented. Therefore, a dynamic cast such as value as? P, where the dynamic type of value conditional conforms to P, will succeed when the conditional requirements are met.

- He also [fixed](https://github.com/apple/swift/pull/14174) an [issue](https://bugs.swift.org/browse/SR-6841) in type checker where class constraints `(spelled T: AnyObject)` on generic types were not getting checked on generic arguments.

[Ben Cohen](https://github.com/airspeedswift) [merged](https://github.com/apple/swift/pull/13342) a pull request that has some more excellent uses of conditional conformances in the Swift standard library. Say goodbye to `(Closed)CountableRange`👋.

[Doug Gregor](https://github.com/DougGregor) [fixed](https://github.com/apple/swift/pull/14174) an [issue](https://bugs.swift.org/browse/SR-6841) in type checker where class constraints `(spelled T: AnyObject)` on generic types were not getting checked on generic arguments.

[Greg Titus](https://github.com/gregomni) [merged](https://github.com/apple/swift/pull/14227) a pull request that removes compiler terminology l-value. As mentioned by Slava Pestov in this [tweet](https://twitter.com/slava_pestov/status/957720067822706688)
> “Removing terminology” is almost always good. Compilers often use terminology that is internal to the implementation, not part of the language model, and can change.

He also [created](https://github.com/apple/swift/pull/14403) a pull request for SILOptimizer that hoists conditional branches out of inner loops by making a true loop & false loop. This basically transforms the pseudocode:

{% highlight swift %}
while(c1) {
    if (c2) {
        [A]
        c2 = expr
    } else {
        [B]
    }
}
{% endhighlight %}
into
{% highlight swift %}

if (c2) {
    while(c1) {
        [A]
        c2 = expr
        if (!c2) goto b_loop
    }
} else {
    b_loop:
    while(c1) {
        [B]
    }
}
{% endhighlight %}

[Morten Bek Ditlevsen](https://github.com/mortenbekditlevsen) created a pull request to add conditional conformance to Hashable for Optional, Dictionary and Array types.

[Nathan Hawes](https://github.com/nathawes) Created a [pull request](https://github.com/apple/swift/pull/14353) to fix a crash in onDocumentUpdateNotification. This was one of the top SourceKit crashes.

[Morten Bek Ditlevsen](https://github.com/mortenbekditlevsen) added Conditional conformance to Hashable for 
- CollectionOfOne, EmptyCollection and Range types. [commit](https://github.com/apple/swift/commit/618df4aeac766fcb8069e90a44b867969a1bc47d)
- Conditional conformance to Hashable for Optional, Dictionary and Array types. (pull request)[https://github.com/apple/swift/pull/14247]

[@eeckstein](https://github.com/eeckstein) [fixed](https://github.com/apple/swift/pull/14338) two issues which prevents incremental llvm compilation.
> - debug-info: Don't write temporary file names in the debug info.
><br/>This would prevent incremental llvm compilation because we would generate different IR on every compiler invocation.
>- SILCombiner: fix a non-determinism in a peephole optimization for load instructions.

[Connor Wakamo](https://github.com/cwakamo) [proposed](https://github.com/apple/swift-evolution/pull/784) to 
Replace PlaygroundQuickLook/CustomPlaygroundQuickLookable with new API
> This proposal has been discussed on the mailing list/forum, and is now ready for official review. As noted in the proposal, parts of it are targeted at Swift 4.1 (deprecation of the old API and introduction of the new API) and others are targeted at Swift 5 (removal of the old API and introduction of a playground-specific shim library).

### Accepted proposals

[SE-0196](https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md): *Compiler Diagnostic Directives* has been accepted but with a minor revision.

>The only revision over the original proposal is to change the syntax to use #warning(<Message>) instead of #warning <Messsage>. This fits well with most of Swift’s existing compiler directives, and was strongly supported in the review discussion.
><br/><br/>The review discussion also covered a variety of possible extensions or variants to this proposal, including support for using #warning as an expression instead of a line directive and support for runtime issues. The Core Team decided that while these directions are interesting and worth exploring, they are complementary to the core functionality serviced by this proposal. Further, keeping #warning as a line directive allows it to be used in a wide variety of contexts, and serves a different need than using it as a placeholder expression.

The proposal was also implemented and [merged](https://github.com/apple/swift-evolution/blob/master/proposals/0196-diagnostic-directives.md) to master. Kudos to [Harlan Haskins](https://github.com/harlanhaskins).

[SE-0197](https://forums.swift.org/t/se-0197-add-in-place-remove-where/8872): *Adding in-place `remove(where:)` to the Standard Library* was accepted.
>The review of this proposal is now over. The core team has decided to accept the proposal with the revision that the method be named `removeAll(where:)`.
In this thread, we also discussed whether to add a `removeAll(_: Element)` method. While I think that’s a reasonable-sounding idea, I do think it can considered independently of SE-0197, since it wasn’t originally part of the pitch. If you’re interested in adding that method, I encourage you to start a new pitch thread for it.

### Returned proposals

> TODO

### Rejected proposals

> TODO

### Proposals in review

[SE-0195](https://github.com/apple/swift-evolution/blob/master/proposals/0195-dynamic-member-lookup.md): *Introduce User-defined “Dynamic Member Lookup” Types*is still under review. It's review was extended by another week.

> The proposal is accepted in principle, but specific details of the proposal need to be further discussed and ironed out. Specifically, there is the matter of using a marker protocol, which raises a bunch of technical questions.
>
> On the general principle of the proposal, the Core Team felt that:
>
> This proposal added valuable functionality to Swift

This proposal is not at odds at potentially adding any new dynamic affordances to Swift later that (say) tie into Swift’s runtime metadata, etc.
There are tooling affordances, such as syntax coloring, that can be used to distinguish methods call going through this member lookup mechanism — without adding additional syntactic weight that would be at odds of some of the core goals of this proposal.

[SE-0198](https://github.com/apple/swift-evolution/blob/master/proposals/0198-playground-quicklook-api-revamp.md): *Playground QuickLook API Revamp is in review.*

> The standard library currently includes API which allows a type to customize its
description in Xcode playgrounds and Swift Playgrounds. This API takes the
form of the `PlaygroundQuickLook` enum which enumerates types which are
supported for quick looks, and the `CustomPlaygroundQuickLookable` protocol
which allows a type to return a custom `PlaygroundQuickLook` value for an
instance.
>
> This is brittle, and to avoid dependency inversions, many of the cases are typed
as taking `Any` instead of a more appropriate type. This proposal suggests that
we deprecate `PlaygroundQuickLook` and `CustomPlaygroundQuickLookable` in Swift
4.1 so they can be removed entirely in Swift 5, preventing them from being
included in the standard library's stable ABI. To maintain compatibility with
older playgrounds, the deprecated symbols will be present in a temporary
compatibility shim library which will be automatically imported in playground
contexts. (This will represent an intentional source break for projects,
packages, and other non-playground Swift code which use `PlaygroundQuickLook` or
`CustomPlaygroundQuickLookable` when they switch to the Swift 5.0 compiler, even
in the compatibility modes.)


[SE-0197](https://forums.swift.org/t/se-0197-add-in-place-remove-where/8872): Adding in-place `remove(where:)` to the Standard Library is in review.

> It is common to want to remove all occurrences of a certain element from a collection. This proposal is to add a remove algorithm to the standard library, which will remove all entries in a collection in-place matching a given predicate.

### Swift Forums

Discussions around Strings:

- [Brent Royal-Gordon](https://github.com/brentdax) started a discussion on [String interpolation revamp](https://forums.swift.org/t/string-interpolation-revamp/9302) and is looking for some ideas to generate fewer temporary strings. <br/>Currenly in Swift interpolation, when you write code like this in Swift 4:

{% highlight swift %}
let foo: MyString = "foo \(bar) baz"
{% endhighlight %}

We currently generate code like below which means we create reference-counted heap objects which are purely temporary and are discarded as soon as the string interpolation is finished.

{% highlight swift %}
let foo = MyString(stringInterpolation: 
	MyString(stringInterpolationSegment: "foo " as String),
	MyString(stringInterpolationSegment: bar),
	MyString(stringInterpolationSegment: " baz" as String)
)
{% endhighlight %}

- [Matthew Johnson](https://github.com/anandabits) started a discussion on [Generalized pattern matching](https://forums.swift.org/t/generalized-pattern-matching/9191).

[Ben Cohen](https://github.com/airspeedswift) started a discussion for [Revisiting the choice of sort algorithm](https://forums.swift.org/t/revisiting-the-choice-of-sort-algorithm/8958)

> `Swift.sort` is currently an [introsort](https://en.wikipedia.org/wiki/Introsort). Introsort is unstable, and there’s been [discussion](https://forums.swift.org/t/add-stable-sort-algorithm/778) over on evolution of adding a stable sort, either instead of or as well as the current sort.<br/><br/>
>The current sort is problematic because it uses recursion heavily, which defeats a number of optimizations relating to ARC and elimination of the overhead of passing in a closure for the comparative for the comparator. This is why we use gyb to stamp out two near identical versions rather than implementing the Equatable version in terms of the closure-taking one.

[Jordan Rose](https://github.com/jrose-apple) started a discussion for [`@_exported` and fixing import visibility](https://forums.swift.org/t/exported-and-fixing-import-visibility/9415).
>Today, if your Swift library “Foo” uses a library “Bar”, the headers (or swiftmodule files) of “Bar” must be available to all clients of “Foo”. This is clearly undesirable, especially when “Bar” is just an implementation detail. (It may even be linked statically.)

### Finally

Let's look at the [change log](https://twitter.com/jckarter/status/959091909129113602) for Swift 5 😃🤣
