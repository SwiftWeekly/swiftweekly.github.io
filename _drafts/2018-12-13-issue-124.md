---
layout: post
title: ! 'Issue #124'
author: fassko
sponsor:
    link: TODO
    heading: TODO
    body: TODO
    displaylink: TODO
---

Welcome to issue 123 of the Weekly Brief!

(Christ)Swiftmas is approaching and you can [celebrate the Advent](https://twitter.com/twostraws/status/1068496131557126145) or have a [challenge](https://adventofcode.com/2018) every day.

Also a lot has hapened in Swift community and seems that team wants to finish all the tasks before the New Year.

<!--excerpt-->

{% include sponsor.html %}

### Starter tasks

> TODO

### Swift Unwrapped

> TODO: Latest episode(s) of Swift Unwrapped

### News and community

Swift Server Work Group had a meeting. Not only they added new members but also they have [discussed some important topics](https://forums.swift.org/t/november-29th-2018/18400).

[Paul Hudson](https://twitter.com/twostraws) wrote [an article](https://www.hackingwithswift.com/articles/134/how-to-use-dynamiccallable-in-swift) explaining how to use @dynamicCallable in Swift.

### Commits and pull requests

> TODO

### Accepted proposals

[SE-0236](https://github.com/apple/swift-evolution/blob/master/proposals/0236-package-manager-platform-deployment-settings.md): *Package Manager Platform Deployment Settings* was [accepted](https://forums.swift.org/t/accepted-with-modifications-se-0236-package-manager-platform-deployment-settings/18420).

> There was a lot of negative feedback about the platform restrictions part of the proposal, so the SwiftPM code owners decided to accept a revised version of the proposal which only handles customization of deployment targets. The topic of platform restrictions for packages can be revisited separately at a later time.
>
> For specifying custom deployment versions, the original proposal mentions that an initializer will be provided. However, since that would be too verbose, a string overload will be provided instead. This makes the API `.macOS("10.13")` instead of `.macOS(MacOSVersion("10.13"))`.

### Returned proposals

Review #2 of [SE-0237: Introduce withUnsafe Mutable BufferPointerIfSupported methods](https://github.com/apple/swift-evolution/blob/master/proposals/0237-contiguous-collection.md)

> The Core Team felt that the use of inout for the closure parameter of withUnsafeMutableBufferPointer(IfSupported) was the best available option, and noted that the library could verify that the UnsafeMutableBufferPointer itself wasn't directly modified by checking for the expected base address / count after the call. This limits the chance of confusion without resorting to shadowing or excessive overloading of mutating operations.
> 
> The two proposed protocols (ContiguousCollection and MutableContiguousCollection) aren't used in any algorithms within the library. It is not clear that they are important enough to introduce as protocols into the Standard Library at this time. The Core Team would like to consider a revised proposal that does not introduce these protocols.
> 
> There are use cases for a Sequence equivalent to the proposed withUnsafeMutableBufferPointerIfSupported, such as initializing a String from a Sequence of UTF-8 code points that are (e.g.) stored in a Data. The Core Team would like to see this addition to the Sequence protocol, which would allow Sequence clients to optimize for the contiguously-stored case without requiring a new protocol, much as the proposal already allows MutableCollection clients to optimize for the contiguously-stored mutable case.

### Rejected proposals

> TODO

### Proposals in review

> TODO

### Swift Forums

Async/Await is not yet implemented, but already there are [ideas how to improve it](https://forums.swift.org/t/proposal-to-add-cancellation-abilities-for-async-await/18419) by addind cancellation abilities.

> The motivation is to provide a consistent and simple API to cancel asynchronous tasks. My theory (seemingly shared by some) is that supporting cancellation is too much trouble for many programmers, because it is a bit involved and the app may still basically work without it. But performance will likely suffer. With this proposal cancellation becomes a simple task so is much more likely to be implemented by app developers.

SwiftNIO team wants to change the [TLS implementation used by swift-nio-ssl](https://forums.swift.org/t/rfc-moving-swiftnio-ssl-to-boringssl/18280).

> We propose to change swift-nio-ssl to stop linking against the system copy of libssl, and instead to provide a vendored copy of BoringSSL 34. This change would come with a number of subtle runtime behavioural changes, as well as a number of substantially more disruptive changes around application distribution and OS behaviour.
> 
> The proposed change would drop support for OpenSSL and LibreSSL. The reasoning for this choice is discussed later in the proposal, and is not necessarily mandatory.
> 
> Note that for Apple platforms the recommended TLS solution will still be to use swift-nio-transport-services.

Last week [JP Simard](https://twitter.com/simjp) wrote how slow is SwiftSyntax. Swift team has [heard it](https://forums.swift.org/t/speeding-up-swiftsyntax-by-using-the-parser-directly/18493].

> tl;dr; Providing direct access to the parser speeds up SwiftSyntax 8x, and it becomes 2x faster than the legacy sourcekitd syntactic request

We all know [Mattt](https://twitter.com/mattt)'s [obsession of Strings](https://www.youtube.com/watch?v=8pnHolNHD2Y) but this time he pitched [Unicode Named Character Escape Sequence](https://forums.swift.org/t/pitch-unicode-named-character-escape-sequence/18396).

>This proposal adds a new \N{name} escape sequence to Swift string literals, where name is the name of a Unicode character.
>
>Each Unicode character is assigned a unique code point, a number between U+0000 — U+10FFFF, and a name, consisting of uppercase letters (A–Z), digits (0–9), hyphens, and spaces. For example, the Unicode character for the letter “A” used in English has the code point U+0041 and the name LATIN CAPITAL LETTER A. The term scalar value defines the subset of Unicode code points that aren’t surrogate pairs.
>
> In Swift, a string literal may include a character directly (“A”) or using the \u{n} escape sequence, where n is a 1–8 digit hexadecimal number corresponding to the scalar value (”\u{0041}”). A string literal may also include character by interpolation (let letterA = ”\u{0041}”; “\(letterA)”).

Discussion about [KeyPaths for Tuples in Swift 5](https://forums.swift.org/t/keypaths-tuples-and-swift-5/18465).

> .. finding out that \SomeType.aTuple.0 does not work ..
> 
> I think this would be a great starter project. The runtime ABI for keypaths should not need any modification to handle tuple components, so there's no rush to implement this. There's an [ABI document](https://github.com/apple/swift/blob/master/docs/ABI/KeyPaths.md) that describes the layout of key path objects; the details are somewhat out of date, but the high level structure is the same

### Finally

> TODO: something funny/fun. tweet, link, etc.
