---
layout: post
title: ! 'Issue #89'
author: roman
---

Welcome to the 89 issue of the swift weekly newsletter! This week is quite and calm, no news explosions. Repositories has usual activity, some tasks was started and mailing list rustle.

<!--excerpt-->

{% include sponsor.html %}

### Starter tasks

Starter tasks are a great way to get started with contributing to Swift. Ask questions right in the bug reporting system, and get feedback when you submit your pull request.

* [SR-5996](https://bugs.swift.org/browse/SR-5996): Improve compiler error with a fix-it: Cannot assign to value, 'bar' is a 'let' constant
* [SR-5995](https://bugs.swift.org/browse/SR-5995): update-checkout --tags should fetch --tags before attempting to find a tag
* [SR-5983](https://bugs.swift.org/browse/SR-5983): Unused result warning phrasing is worse for closures than normal functions
* [SR-5982](https://bugs.swift.org/browse/SR-5982): didSet causes unwanted calls to getter even when oldValue isn't used

{% include task_remind.html %}

### Swift Unwrapped

in [Episode 30](https://spec.fm/podcasts/swift-unwrapped/87409) hosts Jese Squires and JP Simard with Mike Ash discussed changes in weak references implementation in Swift 4.

### News and community
We can celebrate 10th LLVM [anniversary](https://twitter.com/llvmorg/status/912724943221096448)ðŸŽ‰ðŸŽŠ. Project that makes Swift exists. Keep it up, [LLVM](http://llvm.org).

Mike Ash [wrote](https://mikeash.com/pyblog/friday-qa-2017-09-22-swift-4-weak-references.html) great post about changes in Swift weak references implementation from 4th version of language.

> Weak references are an important language feature. Swift's original implementation was wonderfully clever and had some nice properties, but also had some problems. By adding an optional side table, Swift's engineers were able to solve those problems while keeping the nice, clever properties of the original. The side table implementation also opens up a lot of possibilities for great new features in the future.

[Ahmed Sulaiman](https://medium.com/@ahmedsulaiman) wrote descriptive [blog post: Debugging Swift code with LLDB](https://medium.com/flawless-app-stories/debugging-swift-code-with-lldb-b30c5cf2fd49) about using lldb in general and some unpopular tricks with Swift debugging. You can enhance your debugging skills with it.

### Commits and pull requests

[Doug Gregor](https://github.com/DougGregor) [opened pull requests](https://github.com/apple/swift/pull/11923) that implements the standard library part of [SE-0157: Recursive Protocol Constraints](https://github.com/apple/swift-evolution/blob/master/proposals/0157-recursive-protocol-constraints.md).
> - Make the SubSequence associated type have the same capabilities as its enclosing protocol, e.g., Sequence.SubSequence conforms to Sequence, Collection.SubSequence conforms to Collection, and so on.
> - Make the Indices associated type have the same traversal requirements as its enclosing protocol, e.g., Collection.Indices conforms to Collection, BidirectionalCollection.Indices conforms to BidirectionalCollection, and so on
> - Make Numeric.Magnitude conform to Numeric
> - Use more efficient SubSequence types for lazy filter and map
> - Eliminate the *Indexable protocols.

[Joe Groff](https://github.com/jckarter) [fixed](https://github.com/apple/swift/pull/12112) compiler crash in case where code captured *[weak self]* in a closure inside a class method returning dynamic *Self*.

[Jordan Rose](https://github.com/jrose-apple) [merged pull request](https://github.com/apple/swift/pull/12101) with Swift compiler crash fix in situations with Objective-C inheritence from a typedef for a class/protocol composition as shorthand for inheriting from the class and adopting the protocol.

[Philippe Hausler](https://github.com/phausler) [made](https://github.com/apple/swift/pull/11939) great improvement into Data slices. This change fixes [SR-5887](SR-5887), [SR-5873](https://bugs.swift.org/browse/SR-5873) and [SR-5810](https://bugs.swift.org/browse/SR-5810).
> Mutation of Data slices had issues when it comes to re-indexing to the base slice region. Previously when a slice of Data was mutated the re-calculation of the slice region was incorrectly assigned to a relative region to the previous backing. Now the slice region will copy the specific region out creating a new data upon CoW semantics and offset the index region upon access. Mutating a non CoW slice will retain the previous region backing but adjust the remaining allocation buffer accordingly. To validate this I have added tests for combinations that should approximate all possible combinations of mutations, backing storages and CoW scenarios.

[Doug Gregor](https://github.com/DougGregor) [merged pull request](https://github.com/apple/swift/pull/12097) with introduction of caching name lookup for nested types of generic types through the equivalence class.

[Saleem Abdulrasool](https://github.com/compnerd) [added](https://github.com/apple/swift/pull/12136) improvement into Windows ARM headers to support building the runtime.

[Slava Pestov](https://github.com/slavapestov) [merged pull request](https://github.com/apple/swift/pull/12030) with preliminary implementation of a code completion fuzzer.

[Michael Ilseman](https://github.com/milseman) [opened pull request](https://github.com/apple/swift/pull/12115) of prototype implementation for new String comparison.

[Kacper Harasim](https://github.com/Kacper20) [merged](https://github.com/apple/swift/pull/12123) pull request with improvements to refactoring.

### Proposals

No updates on proposals this week. As always, you can check out the [Swift Evolution status page](https://apple.github.io/swift-evolution/) for all the details.

### Mailing lists

> TODO

### Finally

The problem [behind](https://twitter.com/xenadu02/status/911463433521860609) XCode simulator very slow performance is surprising.
