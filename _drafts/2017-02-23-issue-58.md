---
layout: post
title: ! 'Issue #58'
author: jsq
sponsor:
    link: https://forwardswift.com
    heading: ! 'Forward Swift: March 2 in San Francisco + Free Online Workshop Access'
    body: Attend a full day of cutting-edge iOS talks ranging from mirroring and introspection to watchOS. Your ticket includes free networking events with speakers/other devs, and 1 free month of online workshop access post event. Add an exclusive in-person workshops by Paul Hudson on beginning or advanced Swift, macOS, and server-side Swift while they last. Use code **forward-swift-2017**.
---

> TODO: intro comments

<!--excerpt-->

{% include sponsor.html %}

### Starter tasks

In Ted Kremenek's [Swift 4, stage 2](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032116.html) announcement, he mentioned some starter proposals. There's probably two dozen or so [JIRA tasks](https://bugs.swift.org/browse/SR-3397?jql=labels%20%3D%20StarterProposal) that describe these potential proposals and they vary in complexity and difficulty. You should definitely have a look if you're interested in writing a proposal. Checkout the list and see if there's a task for a feature you've been wanting. Remember, proposals can have multiple authors &mdash; so don't hesitate to collaborate with others.

> The Core Team has also identified some [starter proposals](https://bugs.swift.org/browse/SR-3316?jql=labels%20%3D%20StarterProposal) that fit well with the goals of Swift 4. Taking one of those ideas and developing it into a complete proposal is a fantastic way to get involved in the Swift evolution process.

{% include task_remind.html %}

### News and community

Ted Kremenek wrote an official blog post on the [Swift 4 Release Process](https://swift.org/blog/swift-4-0-release-process/), describing the goals, release process, estimated schedule, and how source compatibility will work between Swift 3 and 4.

[Xcode 8.3 beta 3](https://developer.apple.com/news/?id=02202017a) was released.

### Commits and pull requests

> TODO

### Returned proposals

[SE-0155](https://github.com/apple/swift-evolution/blob/master/proposals/0155-normalize-enum-case-representation.md): *Normalize Enum Case Representation* by Daniel Duan and Joe Groff was [reviewed](https://lists.swift.org/pipermail/swift-evolution-announce/2017-February/000323.html) briefly and [returned for revision](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170220/032980.html) early.

From the proposal:

> In Swift 3, associated values for an enum case are represented by a labeled-tuple. This has several undesired effects: inconsistency in enum value construction syntax, many forms of pattern matching, missing features such as specifying default value and missed opportunity for layout improvements.
>
> This proposal aims to make enums more "regular" by replacing tuple as the representation of associated values, making declaration and construction of enum cases more function-like.

John McCall:

> The core team met and talked about SE-0155 today, even though we're not quite done with the review period, and here's where we stand.
>
> SE-0155 is being returned for revision.  Consensus appears to be strongly in favor of requiring argument labels (if provided) to be enforced on "call" sites. However, the core team feels that the proposal needs revision in the following ways:
>
> - Are internal argument names syntactically allowed in a case declaration?
> - Can cases with the same base name be overloaded by argument label?  If so, is a pattern match using just the bare name ambiguous or does it match both cases?
> - Can cases with the same name (using the same rule as above) be overloaded by argument type?  If so, how are they disambiguated in pattern matches?
> - Do pattern matches require argument labels to be given along with value patterns, e.g. "case .valid(value: let value)", or is there some way to shorten this?  If the latter, what are the rules for that?
> - Are you proposing anonymous cases, and if so, what are the language rules for them?
> - The proposal makes a claim about layout efficiency; please either discuss this claim or remove it.

### Proposals in review

[SE-0153](https://github.com/apple/swift-evolution/blob/master/proposals/0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.md): *Compensate for the inconsistency of `@NSCopying`'s behaviour* by Torin Kwok is [under review](https://github.com/apple/swift-evolution/blob/master/proposals/0153-compensate-for-the-inconsistency-of-nscopyings-behaviour.md).

> First of all, in Swift, the Objective-C `copy` property attribute translates to `@NSCopying`.
>
> Like Objective-C, in Swift, avoiding accessing ivar via setter methods in initializer is considered as the best pratice. Unlike Objective-C, which gives developers the freedom to decide on whether assign a value to a property by invoking setter or by accessing ivar directly, accessing a property in Swift from within an initializer always does direct access to the storage rather than going through the setter, even if using `dot` syntax.
>
> However, as a side-effect, `@NSCopying` attribute does not work as consistently as we usually expected in Swift initializers after developers declared a property as `@NSCopying`.
>
> [...]

[SE-0154](https://github.com/apple/swift-evolution/blob/master/proposals/0154-dictionary-key-and-value-collections.md): *Provide Custom Collections for Dictionary Keys and Values* by Nate Cook is [under review](https://lists.swift.org/pipermail/swift-evolution-announce/2017-February/000321.html).

> This proposal addresses significant unexpected performance gaps when using dictionaries. It introduces type-specific collections for a `Dictionary` instance's `keys` and `values` properties.
>
> New collection types provide efficient key lookup and mutable access to dictionary values, allowing in-place updates and copy-on-write optimization of stored values. The addition of these new types impacts the standard library ABI, since we won't be able to use types aliases from the existing types for `keys` and `values`.
> [...]

[SE-0104](https://github.com/apple/swift-evolution/blob/master/proposals/0104-improved-integers.md): *Protocol-oriented integers* is [under review](https://lists.swift.org/pipermail/swift-evolution-announce/2017-February/000322.html) for the third (and final? ðŸ˜…) time. This proposal was accepted for Swift 3, but was not implemented in time.

> This proposal cleans up Swifts integer APIs and makes them more useful for generic programming.
>
> The language has evolved in ways that affect integers APIs since the time the original proposal was approved for Swift 3. We also attempted to implement the proposed model in the standard library and found that some essential APIs were missing, whereas others could be safely removed.
>
> Swift's integer protocols don't currently provide a suitable basis for generic programming. See [this blog post](http://blog.krzyzanowskim.com/2015/03/01/swift_madness_of_generic_integer/) for an example of an attempt to implement a generic algorithm over integers.
>
> [...]

### Deferred proposals

Some proposals that hadn't been pulled into the main [swift-evolution](https://github.com/apple/swift-evolution) repository yet, have already been deferred, as they do not align with the goals of Swift 4.

*Add `\` (backslash character) as operator-head in the grammar* ([Check proposal](https://github.com/nicoFe/swift-evolution/blob/6852513a2e9141aa923a95e7dd1c3f767babbb0f/proposals/0153-add_backslash_character_as_operator-head.md)) has been [deferred](https://github.com/apple/swift-evolution/pull/600#issuecomment-280798535).

> The core team discussed this proposal and determined that it doesn't meet the goals for Swift 4: it is purely additive (and can be added at any time), has no ABI or standard library impact, and there is a minor concern that `\` might be needed as a meta-escaping character somewhere in the future of Swift.

*Default Generic Arguments* ([Check proposal](https://github.com/srdanrasic/swift-evolution/blob/ea7b4488ee2c81a68590db9eb93da196369ffd82/proposals/NNNN-default-generic-arguments.md)) has been [deferred](https://github.com/apple/swift-evolution/pull/591#issuecomment-280798958).

> The core team discussed this proposal and determined that it does not meet the goals for inclusion in Swift 4: it's purely additive, has no ABI impact, is not source-breaking, is a nontrivial feature for a relatively small audience, and has no current standard library impact---and, if it did, it's something we could stage in later without breaking the library ABI.

*Enum Case Blocks* ([Check proposal](https://github.com/timshadel/swift-evolution/blob/a1871e9352c9a2e83bfb9e44edc8fd0b6c68046e/proposals/NNNN-enum-case-blocks.md)) has been [deferred](https://github.com/apple/swift-evolution/pull/585#issuecomment-280799671).

> The core team discussed this proposal and determined that it doesn't fit in the scope of Swift 4: it is purely additive (and could be introduced at any time), is not source-breaking (so it doesn't need to be front-loaded), and does not affect ABI or the standard library.

### Mailing lists

Ted Kremenek announced [Swift 4, stage 2](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032116.html):

> Back in July, we laid out a plan for Swift 4 which divided the release into two stages. Since then, weâ€™ve been in Swift 4 stage 1 [...]
>
> Since July, we now have a much better understanding now of how to achieve ABI stability, with an [ABI Manifesto](https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md) detailing the list of all language/implementation work that is needed to achieve ABI stability. We have made substantial progress in that work during stage 1, but much remains to be done. Once Swift achieves ABI stability the ABI can be extended, but not changed. Thus the cost of locking down an ABI too early is quite high.
>
> **Deferring ABI Stability from Swift 4**<br/>
> Given the importance of getting the core ABI and the related fundamentals correct, we are going to defer the declaration of ABI stability out of Swift 4 while still focusing the majority of effort to get to the point where the ABI can be declared stable.
>
> To allow the community to follow along with this effort, an ABI dashboard will get wired up from the [swift-evolution](https://github.com/apple/swift-evolution) home page that will present a table of main ABI tasks remaining and what Swift release they landed in. This dashboard will largely track open tasks in JIRA. I expect the dashboard to be up next week, and I'll send a follow up email when it is available.
>
> **Stage 2**<br/>
> With ABI stability well-understood and many of the stage 1 goals underway, it is time to open up Swift 4 stage 2 to expand the scope of proposals to be considered.
>
> **Timeline**<br/>
> Stage 2 starts right now.  All design work and discussion for stage 2 extends to April 1, 2017. The intent is to timebox discussion to provide adequate time for the actual implementation of accepted proposals.
>
> [Continue reading...](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20170213/032116.html)

### Finally

And finally &mdash; [using computers The Australian Way](https://twitter.com/b3ll/status/834552936982196224)â„¢. `Â¯\_(ãƒ„)_/Â¯`
